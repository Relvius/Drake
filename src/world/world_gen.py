"""
Overall world generator.
"""

import libtcodpy as lt

"""
Parameters for standalone generation.
"""

WORLD_SIZE = 150
seed = 0
river_number = None

viz = True

"""
Main Controller
"""


def controller():
    heightmap = make_heightmap(WORLD_SIZE, seed)
    rivers = make_rivers(heightmap, WORLD_SIZE, seed, river_number)


"""
Entities
"""


class River:
    def __init__(self, mouth_col, mouth_row, heightmap, size, random):
        self.tiles = []
        rainlevel = 90  # The level above which rivers have a drastically reduced chance to keep flowing.
        move = [(-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0)]  # Directions in order clockwise.

        flowing = True
        last_turns = 0
        current_col = mouth_col
        current_row = mouth_row
        # Pick a starting direction:
        direct = lt.random_get_int(random, 0, 7)   # The first direction we'll go.

        while flowing:
            if 0 <= current_col < size and 0 <= current_row < size:
                self.tiles.append((current_col, current_row))

            found = tuple()
            # Build a new list including the two options around the starting directions.
            new_move = [move[direct - 1], move[direct], move[direct + 1 if direct < 7 else 0]]

            for direction in new_move:
                dx, dy = direction
                value = lt.heightmap_get_value(heightmap, current_row + dx, current_col + dy)
                here = lt.heightmap_get_value(heightmap, current_row, current_col)
                if value > here:
                    if found:
                        if found[1] > value:
                            found = (direction, value)
                    else:
                        found = (direction, value)
                    break
            if found:
                if found[0] == new_move[0]:
                    if last_turns < -2:
                        found = (new_move[1], 0)
                    else:
                        last_turns -= 2
                if found[0] == new_move[2]:
                    if last_turns > 3:
                        found = (new_move[1], 0)
                    else:
                        last_turns += 3
                dx, dy = found[0]
                last_turns += 1 if last_turns < 0 else -1
            elif len(found) == 0:
                dx, dy = new_move[1]
            if here < -19:
                flowing = False

            direct = move.index((dx, dy))
            current_col += dy
            current_row += dx

            if current_col == size or current_row == size or current_col < 0 or current_col < 0:
                flowing = False
            if (current_col, current_row) in self.tiles:
                flowing = False

            # Check if we should still be flowing.
            chance = lt.random_get_float(random, 0, 1)
            if here > rainlevel and chance < 0.4:
                flowing = False
            elif chance < (len(self.tiles)*0.0005) * (here * 0.00005):
                flowing = False

        self.head_col = current_col
        self.head_row = current_row


"""
Steps
"""


def make_heightmap(size, seed):

    # Gradient generated by distance to the northeast corner (creates northeast ocean).
    gradient1 = lt.heightmap_new(size, size)
    for col in xrange(size):
        for row in xrange(size):
            distance = ((row - size)**2 + col**2)**0.5
            lt.heightmap_set_value(gradient1, row, col, distance)
    lt.heightmap_clamp(gradient1, mi=0, ma=WORLD_SIZE)
    lt.heightmap_scale(gradient1, 2)
    # Similar gradient, but cube root (creates mountains around edge).
    gradient2 = lt.heightmap_new(size, size)
    for col in xrange(size):
        for row in xrange(size):
            distance = ((row - size)**2 + col**2)**0.33
            lt.heightmap_set_value(gradient2, row, col, distance)
    lt.heightmap_clamp(gradient2, mi=0, ma=WORLD_SIZE/6)
    lt.heightmap_scale(gradient2, 5)

    # Height map based on Perlin noise.
    heightmap = lt.heightmap_new(size, size)
    random = lt.random_new()
    if seed:
        random = lt.random_new_from_seed(seed)
    perlin = lt.noise_new(2, h=2, l=2, random=random)

    lt.heightmap_add_fbm(
        heightmap, perlin,
        mulx=3, muly=3,
        addx=0, addy=0,
        octaves=8,
        delta=50, scale=100
    )

    # Add in gradients.
    lt.heightmap_add_hm(heightmap, gradient1, heightmap)
    lt.heightmap_add_hm(heightmap, gradient2, heightmap)

    lt.heightmap_normalize(heightmap, mi=-100, ma=105)
    lt.heightmap_clamp(heightmap, mi=-50, ma=100)
    lt.heightmap_normalize(heightmap, mi=-100, ma=100)
    visualize(heightmap)

    return heightmap


def make_rivers(heightmap, size, seed, river_count=None):
    rivers = []
    sealevel = -15
    random = lt.random_new()
    if seed:
        random = lt.random_new_from_seed(seed)
    if river_count is None:
        river_count = lt.random_get_int(random, 10, 15)

    mouths = [(0, 0)]
    for river in xrange(river_count):
        while True:
            setting = True
            col = lt.random_get_int(random, 0, size-1)
            row = lt.random_get_int(random, 0, size-1)
            if sealevel > lt.heightmap_get_value(heightmap, row, col) >= sealevel - 4:
                for mouth in mouths:
                    if abs(col - mouth[0]) < 5 and abs(row - mouth[1]) < 5:
                        setting = False
                if setting:
                    mouths.append((col, row))
                    rivers.append(River(col, row, heightmap, size, random))
                    break
    visualize(rivers, False)

    # Clean up inappropriate rivers.
    to_remove = set()
    i = -1
    for river in rivers:
        i += 1
        if len(river.tiles) < 15:
            to_remove.add(i)
        if lt.heightmap_get_value(heightmap, river.head_row, river.head_col) < 30:
            to_remove.add(i)
        for other in rivers:
            if river != other:
                x = True
                for n in list(to_remove):
                    if other == rivers[n] or river == rivers[n]:
                        x = False
                if x:
                    for (this_x, this_y) in river.tiles:
                        for (other_x, other_y) in other.tiles:
                            distance = ((this_x - other_x)**2 + (this_y - other_y)**2)**0.5
                            if distance < 2:
                                to_remove.add(i)
                                break
    remove = sorted(list(to_remove), reverse=True)
    for n in remove:
        rivers.pop(n)

    if len(rivers) > 0:
        visualize(heightmap, False)
        visualize(rivers)
    else:
        visualize(heightmap)

    return rivers



"""
Visualizing
"""


def visualize(area, click=True):
    if viz:
        # Heightmap rendering
        if isinstance(area, lt.HeightMap):
            lt.console_clear(river_con)
            lt.console_clear(0)
            for col in xrange(WORLD_SIZE):
                for row in xrange(WORLD_SIZE):
                    value = int(lt.heightmap_get_value(area, row, col)) + 15

                    color = lt.Color((170-int(value*1.7)), (160 - value), (80 - value/2))
                    if value < 0:
                        color = lt.Color(0, (50 + value/2), (100 + value))
                    elif value > 100:
                        n = int(value*1.3)
                        color = lt.Color(n, n, n)

                    """
                    color = lt.black
                    if 100 >= value > 85:   color = lt.lighter_gray
                    elif 85 >= value > 50:  color = lt.darkest_green
                    elif 50 >= value > 10:  color = lt.darker_green
                    elif 10 >= value > 0:   color = lt.dark_yellow
                    elif 0 >= value > -30:  color = lt.darker_azure
                    elif -30 >= value >= -100: color = lt.darkest_azure
                    """

                    lt.console_set_char_background(con, row, col, color, lt.BKGND_SET)
            lt.console_blit(con, 0, 0, 0, 0, 0, 0, 0)

        # River rendering
        if isinstance(area, list):
            if isinstance(area[0], River):
                lt.console_clear(river_con)
                for river in area:
                    for tile in river.tiles:
                        y, x = tile
                        lt.console_set_char_background(river_con, x, y, lt.azure, lt.BKGND_SET)
                lt.console_blit(river_con, 0, 0, 0, 0, 0, 0, 0)

        lt.console_flush()

        if click:
            while True:
                key = lt.console_wait_for_keypress(False)
                if key.pressed:
                    break

if viz:
    lt.console_set_custom_font('data/fonts/arialtiny.png', lt.FONT_TYPE_GRAYSCALE | lt.FONT_LAYOUT_TCOD)
    lt.console_init_root(WORLD_SIZE, WORLD_SIZE, 'Visualizer', False)
    con = lt.console_new(WORLD_SIZE, WORLD_SIZE)
    river_con = lt.console_new(WORLD_SIZE, WORLD_SIZE)
    lt.console_set_key_color(river_con, lt.black)

    controller()
    while True:
        key = lt.console_wait_for_keypress(False)
        if key.vk == lt.KEY_ESCAPE:
            break
        elif key.c:
            controller()
